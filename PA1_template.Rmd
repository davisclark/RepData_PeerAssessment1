---
title: "Reproducible Research: Peer Assessment 1"
author: "Davis Clark"
date: "Friday, April 17, 2015"
output: html_document
keep_md: true
---
###Configure R environment  
```{r config, message=FALSE}
library(knitr)
library(lubridate)
library(reshape2)
library(dplyr)
library(ggplot2)

knitr::opts_chunk$set(echo = TRUE, fig.path = 'figure/plot-', cache = FALSE)
```

###Load and process data
Before we begin to analyze our data, it's essential that we process and prepare our dataset. Of course, to do so, we must first store the dataset in-memory.

The following code will scan the current working directory to check whether the necessary file is present. 
If it is not, it downloads the file from the provided URL before continuing to process. If the file is present, the file is passed to read.csv() and stored within the "active" object. 

```{r data import}
fileUrl <- "http://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip"

if(!("activity.zip" %in% list.files())) {
        download.file(fileUrl, "activity.zip")
        unzip("activity.zip")
}

activity <- read.csv("./activity.csv")
```

After transforming the date column into the date data type, we then use the reshape2 package to melt the data frame and create two additional dataframes, which:

* dailyTotal summarizes our activity data by computing the sum of our daily steps
* meanInterval summarizes our activity data by computing the mean of each interval over the two-month period of data

```{r formatting}
activity$date <- ymd(activity$date)

activityMelt <- melt(activity, measure.vars = "steps")
```

### What is mean total number of steps taken per day?
For this part of the assignment, you can ignore the missing values in
the dataset.

The total amount of steps taken daily can be found by running dcast on activityMelt:
```{r}
dailyTotal <- dcast(activityMelt, date ~ variable, sum)
```

We can then plot the frequency of daily total steps using ggplot2's histogram functionality:

```{r histogram with missing values}
ggplot(dailyTotal, aes(x=steps)) + geom_histogram()
```

Running the mean and median functions on the dailyTotal steps vector (while ignoring NA values) returns:

```{r}
mean(dailyTotal$steps, na.rm = TRUE)
median(dailyTotal$steps, na.rm = TRUE)
```

### What is the average daily activity pattern?
To find the average daily activity pattern, we can again summarize our activity datafram by way of melt and dcast:

```{r}
meanInterval <- arrange(dcast(activityMelt, interval ~ variable, mean, na.rm = TRUE), interval)
```

Using the ggplot2 line type, the average daily activity pattern is plotted by interval:

```{r average steps}
ggplot(meanInterval, aes(interval, steps)) + geom_line()
```

Although our timeseries visualization gives us an excellent view of the data's overall shape, we'll run the max function on the vector to pinpoint the specific, related values:

```{r}
meanInterval[(meanInterval$steps == max(meanInterval$steps)), 1]
```

###Imputing missing values
Complete.cases returns a logical vector that indicates the rows, or observations, that are complete (i.e. no missing values.) When negated, this vector provides the location of every row that is incomplete (i.e. missing a value.) 

Adding the values of the negated vector (which is filled with '0's and '1's), we find the number of rows missing a value in at least one place:
```{r}
sum(!complete.cases(activity))
```

Using the same negated vector, we can subset our activity set to obtain a dataframe filled exclusively with incomplete observations. After merging this dataframe with the set of average interval values calculated earler, we can fill the missing values with the average value respective the interval and inject our adjusted dataframe into our original activity frame: 
```{r}
fillByIntervalMeans <- arrange(select(merge(activity[(!complete.cases(activity)), ], meanInterval, by = "interval"), steps.y, date, interval), date, interval)
names(fillByIntervalMeans)[1] <- "steps"
activity[(!complete.cases(activity)), ] <- fillByIntervalMeans

activityMelt <- melt(activity, measure.vars = "steps")

dailyTotal <- dcast(activityMelt, date ~ variable, sum)
```

An adjusted histogram, mean, and median can now be found:

```{r histogram without missing values}
ggplot(dailyTotal, aes(x=steps)) + geom_histogram()

mean(dailyTotal$steps)
median(dailyTotal$steps)
```

Although the mean statistic remains equivalent to the mean value previously calculated, our median statistic is slightly greater than our median calculated earlier and is now equal to our mean. This is to be expected, as the exclusion of NA values from consideration will skew the 50th percentile, despite the relatively insignficant impact on the mean. 

###Are there differences in activity patterns between weekdays and weekends?
We first create our new factor variable, using weekdays() to return the date day of the week. We can split the dataframe in two, based upon our new factor, calculate the mean of each 5-minute interval, and rbind the sets into one dataframe again:

```{r}
week <- mutate(activityMelt, weekday = factor(weekdays(date) %in% c("Saturday", "Sunday"), labels = c("weekday", "weekend")))

weekday <- mutate(dcast(week[(week$weekday == "weekday"), ], interval ~ variable, mean), group = "weekday")
weekend <- mutate(dcast(week[(week$weekday == "weekend"), ], interval ~ variable, mean), group = "weekend")

week <- arrange(rbind(weekday, weekend), interval)
```

And thanks to our new factor, plotting the set proves simple:

```{r}
ggplot(week, aes(interval, steps)) + geom_line() + facet_grid(group ~ .)
```


